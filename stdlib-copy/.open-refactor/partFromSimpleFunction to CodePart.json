{
  "name": "partFromSimpleFunction to CodePart",
  "instructions": "Your goal is to convert calls such as: ``` export const DateFromString = partFromSimpleFunction({   id: \"Date From String\",   icon: \"fa-calendar\",   namespace,   description: \"Creates a date from a string\",   inputs: [{ name: \"string\", description: \"String\" }],   output: { name: \"date\", description: \"Date\" },   run: (string) => new Date(string), }); ```  Into:  ``` export const DateFromString: CodePart = {   id: \"Date From String\",   defaultStyle: {     icon: \"fa-calendar\",   },   namespace,   description: \"Creates a date from a string\",   inputs: { string: { description: \"String\" } },   outputs: { date: { description: \"Date\" } },   run: ({ string }, { date }) => date.next(new Date(string)), }; ```  For reference, here is the partFromSimpleFunction code:  ``` import { BasePart, CodePart, PartStyleSize, RunPartFunction } from \".\"; import { InputMode } from \"./part-pins\";  export type SimpleFnData = Omit<BasePart, \"inputs\" | \"outputs\" | \"run\"> & {   id: string;   description: string;   namespace: string;   inputs?: {     name: string;     description: string;     mode?: InputMode;     defaultValue?: any;   }[];   output?: { name: string; description: string };   run?: (...args: any[]) => any;   symbol?: string;   icon?: string;   size?: PartStyleSize;   customViewCode?: string;   fullRunFn?: RunPartFunction; // hack to start migrating these back };  export function partFromSimpleFunction(data: SimpleFnData): CodePart {   return {     ...data,     id: data.id,     description: data.description,     namespace: data.namespace,     inputs: data.inputs       ? data.inputs.reduce(           (obj, { name, description, mode, defaultValue }) => ({             ...obj,             [name]: { description, mode: mode ?? \"required\", defaultValue },           }),           {}         )       : {},     outputs: data.output       ? { [data.output.name]: { description: data.output.description } }       : {},     defaultStyle: {       icon: data.icon,       size: data.size,     },     run:       data.fullRunFn ??       async function (inputs, outputs, adv) {         const args = (data.inputs ?? []).map(({ name }) => inputs[name]);         try {           const result = await Promise.resolve(data.run(...args));           if (data.output) {             outputs[data.output.name]?.next(result);           }         } catch (e) {           console.error(\"Error in part\", e);           adv.onError(e);         }       },     customViewCode: data.customViewCode,   }; } ```  You will receive code from the user and return the transformed code, without any explanation. If you encounter an unknown pattern, you may output \"Error!\" with the details instead. - Do not add console logs or errors of your own",
  "totalTokensUsed": 58208,
  "createdAt": 1684954822800,
  "timesUsed": 30
}